!function(e){var n={};function r(t){if(n[t])return n[t].exports;var o=n[t]={i:t,l:!1,exports:{}};return e[t].call(o.exports,o,o.exports,r),o.l=!0,o.exports}r.m=e,r.c=n,r.d=function(e,n,t){r.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,n){if(1&n&&(e=r(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(r.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var o in e)r.d(t,o,function(n){return e[n]}.bind(null,o));return t},r.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(n,"a",n),n},r.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},r.p="",r(r.s=3)}([function(module,exports){eval('module.exports = require("graphql");\n\n//# sourceURL=webpack:///external_%22graphql%22?')},function(module,exports){eval('module.exports = require("sequelize");\n\n//# sourceURL=webpack:///external_%22sequelize%22?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// EXTERNAL MODULE: external "graphql"\nvar external_graphql_ = __webpack_require__(0);\n\n// EXTERNAL MODULE: external "sequelize"\nvar external_sequelize_ = __webpack_require__(1);\nvar external_sequelize_default = /*#__PURE__*/__webpack_require__.n(external_sequelize_);\n\n// CONCATENATED MODULE: ./src/models/utils.js\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\nfunction buildWhere(whereObj) {\n  if (!whereObj || !Object.keys(whereObj).length) {\n    return;\n  }\n\n  return {\n    where: Object.keys(whereObj).reduce(function (acc, columnName) {\n      if (Array.isArray(whereObj[columnName])) {\n        acc[columnName] = _defineProperty({}, external_sequelize_["Op"].or, whereObj[columnName]);\n      } else {\n        acc[columnName] = whereObj[columnName];\n      }\n\n      return acc;\n    }, {})\n  };\n}\n\n/* harmony default export */ var utils = ({\n  buildWhere: buildWhere\n});\n// CONCATENATED MODULE: ./src/services/base.js\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar base_default =\n/*#__PURE__*/\nfunction () {\n  function _default(model) {\n    _classCallCheck(this, _default);\n\n    this.model = model;\n  }\n\n  _createClass(_default, [{\n    key: "findById",\n    value: function () {\n      var _findById = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee(id) {\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt("return", this.model.findByPk(id));\n\n              case 1:\n              case "end":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function findById(_x) {\n        return _findById.apply(this, arguments);\n      }\n\n      return findById;\n    }()\n  }, {\n    key: "findByIds",\n    value: function () {\n      var _findByIds = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee2(ids) {\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt("return", this.findAll({\n                  id: ids\n                }));\n\n              case 1:\n              case "end":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function findByIds(_x2) {\n        return _findByIds.apply(this, arguments);\n      }\n\n      return findByIds;\n    }()\n  }, {\n    key: "findAll",\n    value: function () {\n      var _findAll = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee3(query) {\n        var found;\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.model.findAll(utils.buildWhere(query));\n\n              case 2:\n                found = _context3.sent;\n                return _context3.abrupt("return", found ? found : []);\n\n              case 4:\n              case "end":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function findAll(_x3) {\n        return _findAll.apply(this, arguments);\n      }\n\n      return findAll;\n    }()\n  }, {\n    key: "createOne",\n    value: function () {\n      var _createOne = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee4(obj) {\n        return regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                return _context4.abrupt("return", this.model.create(obj));\n\n              case 1:\n              case "end":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function createOne(_x4) {\n        return _createOne.apply(this, arguments);\n      }\n\n      return createOne;\n    }()\n  }, {\n    key: "createMany",\n    value: function () {\n      var _createMany = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee5(objs) {\n        return regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt("return", this.model.bulkCreate(objs));\n\n              case 1:\n              case "end":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function createMany(_x5) {\n        return _createMany.apply(this, arguments);\n      }\n\n      return createMany;\n    }()\n  }]);\n\n  return _default;\n}();\n\n\n// CONCATENATED MODULE: ./src/models/connection.js\n\nvar sequelize = new external_sequelize_default.a(\'codified-spanish\', \'alavery\', \'\', {\n  host: \'localhost\',\n  dialect: \'postgres\',\n  define: {\n    // camelCase -> snake_case\n    underscored: true,\n    // don\'t add an "s" to table name\n    freezeTableName: true\n  }\n}); // const sequelize = new Sequelize(\'postgres://juwfhddomnoezp:f9db989b90cbefb145aff0dbc50f7ec243de9f4b7eb2756061d56aa762ed5b2c@ec2-54-83-9-36.compute-1.amazonaws.com:5432/dd3am2e2dguhs1\', {\n//     dialect:  \'postgres\',\n//     protocol: \'postgres\',\n//     define: {\n//         // camelCase -> snake_case\n//         underscored: true,\n//         // don\'t add an "s" to table name\n//         freezeTableName: true,\n//     },\n//     "ssl": true,\n//     "dialectOptions": { "ssl": true }\n// });\n\nsequelize.authenticate().then(function () {\n  console.log(\'Connection has been established successfully.\');\n})["catch"](function (err) {\n  console.error(\'Unable to connect to the database:\', err);\n});\nsequelize.sync();\n/* harmony default export */ var connection = (sequelize);\n// CONCATENATED MODULE: ./src/models/word/index.js\n\n\n/* harmony default export */ var models_word = (connection.define(\'word\', {\n  id: {\n    type: external_sequelize_default.a.UUID,\n    primaryKey: true\n  },\n  string: {\n    type: external_sequelize_default.a.STRING,\n    allowNull: false\n  },\n  partOfSpeech: {\n    type: external_sequelize_default.a.STRING,\n    allowNull: false\n  },\n  person: {\n    type: external_sequelize_default.a.INTEGER,\n    allowNull: true\n  },\n  mood: {\n    type: external_sequelize_default.a.STRING,\n    allowNull: true\n  },\n  tense: {\n    type: external_sequelize_default.a.STRING,\n    allowNull: true\n  },\n  isPlural: {\n    type: external_sequelize_default.a.BOOLEAN,\n    allowNull: true\n  },\n  gender: {\n    type: external_sequelize_default.a.STRING,\n    allowNull: true\n  }\n}));\n// CONCATENATED MODULE: ./src/models/lemma/index.js\n\n\n/* harmony default export */ var lemma = (connection.define(\'lemma\', {\n  id: {\n    type: external_sequelize_default.a.UUID,\n    primaryKey: true\n  },\n  string: {\n    type: external_sequelize_default.a.STRING,\n    allowNull: false\n  },\n  partOfSpeech: {\n    type: external_sequelize_default.a.STRING,\n    allowNull: false\n  },\n  meanings: {\n    type: external_sequelize_default.a.ARRAY(external_sequelize_default.a.STRING),\n    allowNull: true\n  }\n}));\n// CONCATENATED MODULE: ./src/models/user/index.js\n\n\n/* harmony default export */ var user = (connection.define(\'user\', {\n  name: {\n    type: external_sequelize_default.a.STRING,\n    allowNull: false\n  }\n}));\n// CONCATENATED MODULE: ./src/models/userWord/index.js\n\n\n/* harmony default export */ var userWord = (connection.define(\'user_word\', {\n  strength: {\n    type: external_sequelize_default.a.INTEGER,\n    allowNull: true\n  }\n}));\n// CONCATENATED MODULE: ./src/models/index.js\n\n\n\n\nlemma.hasMany(models_word);\nmodels_word.belongsTo(lemma);\nmodels_word.hasMany(userWord);\nuser.hasMany(userWord);\nuserWord.belongsTo(models_word);\nuserWord.belongsTo(user);\n\n// CONCATENATED MODULE: ./src/services/lemma.js\n\n\n/* harmony default export */ var services_lemma = (new base_default(lemma));\n// CONCATENATED MODULE: ./src/services/word.js\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction word_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction word_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { word_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { word_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\nfunction word_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction word_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction word_createClass(Constructor, protoProps, staticProps) { if (protoProps) word_defineProperties(Constructor.prototype, protoProps); if (staticProps) word_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\nvar word_WordService =\n/*#__PURE__*/\nfunction (_BaseService) {\n  _inherits(WordService, _BaseService);\n\n  function WordService() {\n    word_classCallCheck(this, WordService);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(WordService).apply(this, arguments));\n  }\n\n  word_createClass(WordService, [{\n    key: "getLemmaIds",\n    value: function () {\n      var _getLemmaIds = word_asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee(lemmaStrings) {\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return services_lemma.findAll({\n                  string: lemmaStrings\n                });\n\n              case 2:\n                _context.t0 = function (lemma) {\n                  return lemma.id;\n                };\n\n                return _context.abrupt("return", _context.sent.map(_context.t0));\n\n              case 4:\n              case "end":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function getLemmaIds(_x) {\n        return _getLemmaIds.apply(this, arguments);\n      }\n\n      return getLemmaIds;\n    }()\n  }, {\n    key: "getWordsOfGivenLemmaAndProperties",\n    value: function () {\n      var _getWordsOfGivenLemmaAndProperties = word_asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee2(lemmaId, properties) {\n        var nonNilProperties;\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                nonNilProperties = Object.keys(properties).reduce(function (acc, propName) {\n                  if (properties[propName] || properties[propName] === 0) {\n                    acc[propName] = properties[propName];\n                  }\n\n                  return acc;\n                }, {});\n                nonNilProperties.lemmaId = lemmaId;\n                return _context2.abrupt("return", this.findAll(nonNilProperties));\n\n              case 3:\n              case "end":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getWordsOfGivenLemmaAndProperties(_x2, _x3) {\n        return _getWordsOfGivenLemmaAndProperties.apply(this, arguments);\n      }\n\n      return getWordsOfGivenLemmaAndProperties;\n    }()\n  }]);\n\n  return WordService;\n}(base_default);\n\n/* harmony default export */ var services_word = (new word_WordService(models_word));\n// CONCATENATED MODULE: ./src/schema/word/types/wordType.js\nfunction wordType_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction wordType_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { wordType_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { wordType_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\n\n\nvar fields = {\n  id: {\n    type: external_graphql_["GraphQLID"]\n  },\n  string: {\n    type: external_graphql_["GraphQLString"]\n  },\n  partOfSpeech: {\n    type: external_graphql_["GraphQLString"]\n  },\n  tense: {\n    type: external_graphql_["GraphQLString"]\n  },\n  lemmaId: {\n    type: external_graphql_["GraphQLID"]\n  },\n  lemma: {\n    type: new external_graphql_["GraphQLObjectType"]({\n      name: \'lemma\',\n      fields: {\n        id: {\n          type: external_graphql_["GraphQLID"]\n        },\n        string: {\n          type: external_graphql_["GraphQLString"]\n        },\n        partOfSpeech: {\n          type: external_graphql_["GraphQLString"]\n        },\n        meanings: {\n          type: external_graphql_["GraphQLList"](external_graphql_["GraphQLString"])\n        }\n      }\n    }),\n    // todo this should be SQL joined instead of manually fetched\n    // with the resolver.  That way, can fetch all the lemmas in\n    // one SQL call as the words are fetched instead of each one\n    // individually after the words are fetched\n    resolve: function () {\n      var _resolve = wordType_asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee(word) {\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(word && word.dataValues)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt("return", services_lemma.findById(word.dataValues.lemmaId));\n\n              case 2:\n                return _context.abrupt("return", {});\n\n              case 3:\n              case "end":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function resolve(_x) {\n        return _resolve.apply(this, arguments);\n      }\n\n      return resolve;\n    }()\n  }\n};\n/* harmony default export */ var wordType = (new external_graphql_["GraphQLObjectType"]({\n  name: \'word\',\n  fields: fields\n}));\n// CONCATENATED MODULE: ./src/schema/word/queries/getWords.js\nfunction getWords_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction getWords_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { getWords_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { getWords_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\n\n\n // each argument will be a GraphQLList of the field type\n\nvar getWords_args = Object.keys(fields).reduce(function (acc, fieldName) {\n  if (fieldName !== \'lemma\') {\n    acc[fieldName] = {\n      type: external_graphql_["GraphQLList"](fields[fieldName].type)\n    };\n  } else {\n    // for the lemma, they should query\n    acc[fieldName] = {\n      type: external_graphql_["GraphQLList"](external_graphql_["GraphQLString"])\n    };\n  }\n\n  return acc;\n}, {});\n/* harmony default export */ var getWords = ({\n  type: external_graphql_["GraphQLList"](wordType),\n  args: getWords_args,\n  resolve: function () {\n    var _resolve = getWords_asyncToGenerator(\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function _callee(_, args) {\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.t0 = services_word;\n              _context.next = 3;\n              return resolveArgs(args);\n\n            case 3:\n              _context.t1 = _context.sent;\n              return _context.abrupt("return", _context.t0.findAll.call(_context.t0, _context.t1));\n\n            case 5:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    function resolve(_x, _x2) {\n      return _resolve.apply(this, arguments);\n    }\n\n    return resolve;\n  }()\n});\n\nfunction resolveArgs(_x3) {\n  return _resolveArgs.apply(this, arguments);\n}\n\nfunction _resolveArgs() {\n  _resolveArgs = getWords_asyncToGenerator(\n  /*#__PURE__*/\n  regeneratorRuntime.mark(function _callee2(args) {\n    var resolved;\n    return regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            resolved = Object.keys(args).reduce(function (acc, key) {\n              if (key !== \'lemma\') {\n                acc[key] = args[key];\n              }\n\n              return acc;\n            }, {});\n\n            if (!args.lemma) {\n              _context2.next = 5;\n              break;\n            }\n\n            _context2.next = 4;\n            return services_word.getLemmaIds(args.lemma);\n\n          case 4:\n            resolved.lemmaId = _context2.sent;\n\n          case 5:\n            return _context2.abrupt("return", resolved);\n\n          case 6:\n          case "end":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _resolveArgs.apply(this, arguments);\n}\n// CONCATENATED MODULE: ./src/schema/word/index.js\n\n/* harmony default export */ var schema_word = ({\n  queries: {\n    words: getWords\n  },\n  mutations: {}\n});\n// CONCATENATED MODULE: ./src/services/user.js\n\n\n/* harmony default export */ var services_user = (new base_default(user));\n// CONCATENATED MODULE: ./src/schema/user/queries/getUserById.js\nfunction getUserById_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction getUserById_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { getUserById_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { getUserById_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\n\n\nvar getUserById_user = new external_graphql_["GraphQLObjectType"]({\n  name: \'user\',\n  fields: {\n    id: {\n      type: external_graphql_["GraphQLString"]\n    },\n    name: {\n      type: external_graphql_["GraphQLString"]\n    }\n  }\n});\n/* harmony default export */ var getUserById = ({\n  type: getUserById_user,\n  args: {\n    id: {\n      type: external_graphql_["GraphQLID"]\n    }\n  },\n  resolve: function () {\n    var _resolve = getUserById_asyncToGenerator(\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function _callee(_, args) {\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt("return", services_user.findById(args.id));\n\n            case 1:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    function resolve(_x, _x2) {\n      return _resolve.apply(this, arguments);\n    }\n\n    return resolve;\n  }()\n});\n// CONCATENATED MODULE: ./src/schema/user/mutations/createUser.js\nfunction createUser_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction createUser_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { createUser_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { createUser_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\n\n\nvar userType = new external_graphql_["GraphQLObjectType"]({\n  name: \'User\',\n  fields: {\n    id: {\n      type: external_graphql_["GraphQLID"]\n    },\n    name: {\n      type: external_graphql_["GraphQLString"]\n    }\n  }\n});\n/* harmony default export */ var createUser = ({\n  type: userType,\n  args: {\n    name: {\n      type: external_graphql_["GraphQLString"]\n    }\n  },\n  resolve: createUser_resolve\n});\n\nfunction createUser_resolve(_x, _x2) {\n  return mutations_createUser_resolve.apply(this, arguments);\n}\n\nfunction mutations_createUser_resolve() {\n  mutations_createUser_resolve = createUser_asyncToGenerator(\n  /*#__PURE__*/\n  regeneratorRuntime.mark(function _callee(_, args) {\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt("return", services_user.createOne(args));\n\n          case 1:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return mutations_createUser_resolve.apply(this, arguments);\n}\n// CONCATENATED MODULE: ./src/schema/user/index.js\n\n\n/* harmony default export */ var schema_user = ({\n  queries: {\n    getUserById: getUserById\n  },\n  mutations: {\n    createUser: createUser\n  }\n});\n// CONCATENATED MODULE: ./src/services/userWord.js\n\n\n/* harmony default export */ var services_userWord = (new base_default(userWord));\n// CONCATENATED MODULE: ./src/schema/userKnowledge/queries/getUserKnownWords.js\nfunction getUserKnownWords_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction getUserKnownWords_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { getUserKnownWords_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { getUserKnownWords_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\n\n\n\n\n/* harmony default export */ var getUserKnownWords = ({\n  type: external_graphql_["GraphQLList"](wordType),\n  args: {\n    userId: {\n      type: external_graphql_["GraphQLID"]\n    }\n  },\n  resolve: function () {\n    var _resolve = getUserKnownWords_asyncToGenerator(\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function _callee(_, args) {\n      var userWords;\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return services_userWord.findAll({\n                userId: args.userId\n              });\n\n            case 2:\n              userWords = _context.sent;\n\n              if (userWords.length) {\n                _context.next = 5;\n                break;\n              }\n\n              return _context.abrupt("return", []);\n\n            case 5:\n              return _context.abrupt("return", services_word.findByIds(userWords.map(function (uw) {\n                return uw.wordId;\n              })));\n\n            case 6:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    function resolve(_x, _x2) {\n      return _resolve.apply(this, arguments);\n    }\n\n    return resolve;\n  }()\n});\n// CONCATENATED MODULE: ./src/schema/userKnowledge/types/userKnownWord.js\n\n/* harmony default export */ var userKnownWord = (new external_graphql_["GraphQLObjectType"]({\n  name: \'UserKnownWord\',\n  fields: {\n    id: {\n      type: external_graphql_["GraphQLID"]\n    },\n    wordId: {\n      type: external_graphql_["GraphQLID"]\n    },\n    userId: {\n      type: external_graphql_["GraphQLID"]\n    }\n  }\n}));\n// CONCATENATED MODULE: ./src/schema/userKnowledge/mutations/addUserKnownWords.js\nfunction addUserKnownWords_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction addUserKnownWords_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { addUserKnownWords_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { addUserKnownWords_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\n\n\n\n\n/* harmony default export */ var addUserKnownWords = ({\n  type: external_graphql_["GraphQLList"](userKnownWord),\n  args: {\n    userId: {\n      type: external_graphql_["GraphQLString"]\n    },\n    wordIds: {\n      type: external_graphql_["GraphQLList"](external_graphql_["GraphQLID"])\n    },\n    lemmaId: {\n      type: external_graphql_["GraphQLID"]\n    },\n    tense: {\n      type: external_graphql_["GraphQLString"]\n    },\n    person: {\n      type: external_graphql_["GraphQLInt"]\n    }\n  },\n  resolve: addUserKnownWords_resolve\n});\n\nfunction addUserKnownWords_resolve(_x, _x2) {\n  return mutations_addUserKnownWords_resolve.apply(this, arguments);\n}\n\nfunction mutations_addUserKnownWords_resolve() {\n  mutations_addUserKnownWords_resolve = addUserKnownWords_asyncToGenerator(\n  /*#__PURE__*/\n  regeneratorRuntime.mark(function _callee(_, args) {\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (args.userId) {\n              _context.next = 2;\n              break;\n            }\n\n            throw new Error("userId is required!");\n\n          case 2:\n            if (!args.lemmaId) {\n              _context.next = 7;\n              break;\n            }\n\n            _context.next = 5;\n            return services_word.getWordsOfGivenLemmaAndProperties(args.lemmaId, {\n              tense: args.tense,\n              person: args.person\n            });\n\n          case 5:\n            _context.t0 = function (word) {\n              return word.id;\n            };\n\n            args.wordIds = _context.sent.map(_context.t0);\n\n          case 7:\n            if (!(!args.wordIds || !args.wordIds.length)) {\n              _context.next = 9;\n              break;\n            }\n\n            return _context.abrupt("return", []);\n\n          case 9:\n            return _context.abrupt("return", services_userWord.createMany(args.wordIds.map(function (wordId) {\n              return {\n                wordId: wordId,\n                userId: args.userId\n              };\n            })));\n\n          case 10:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return mutations_addUserKnownWords_resolve.apply(this, arguments);\n}\n// CONCATENATED MODULE: ./src/schema/userKnowledge/index.js\n\n\n/* harmony default export */ var userKnowledge = ({\n  queries: {\n    getUserKnownWords: getUserKnownWords\n  },\n  mutations: {\n    addUserKnownWords: addUserKnownWords\n  }\n});\n// CONCATENATED MODULE: ./src/schema/index.js\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { schema_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction schema_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\nvar queryFields = _objectSpread({}, schema_word.queries, {}, schema_user.queries, {}, userKnowledge.queries);\n\nvar mutationFields = _objectSpread({}, schema_word.mutations, {}, schema_user.mutations, {}, userKnowledge.mutations);\n\n/* harmony default export */ var schema = __webpack_exports__["a"] = (new external_graphql_["GraphQLSchema"](_objectSpread({}, Object.keys(queryFields).length ? {\n  query: new external_graphql_["GraphQLObjectType"]({\n    name: \'RootQueryType\',\n    fields: queryFields\n  })\n} : {}, {}, Object.keys(mutationFields).length ? {\n  mutation: new external_graphql_["GraphQLObjectType"]({\n    name: \'RootMutationType\',\n    fields: mutationFields\n  })\n} : {})));\n\n//# sourceURL=webpack:///./src/schema/index.js_+_22_modules?')},function(module,exports,__webpack_require__){eval("module.exports = __webpack_require__(4);\n\n\n//# sourceURL=webpack:///multi_./src/index.js?")},function(module,exports,__webpack_require__){eval("__webpack_require__(5);\n\n__webpack_require__(6);\n\n//# sourceURL=webpack:///./src/index.js?")},function(module,exports){eval('module.exports = require("regenerator-runtime/runtime");\n\n//# sourceURL=webpack:///external_%22regenerator-runtime/runtime%22?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(process) {/* harmony import */ var _schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\nvar express = __webpack_require__(8);\n\nvar graphqlHTTP = __webpack_require__(9);\n\n\nvar app = express(); // const process = require(\'process\');\n\napp.use(\'/\', graphqlHTTP({\n  schema: _schema__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"],\n  graphiql: true\n}));\nvar port = process.env.PORT || 4000;\napp.listen(port, function () {\n  console.log("Listening on port ".concat(port, "..."));\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(7)))\n\n//# sourceURL=webpack:///./src/app.js?')},function(module,exports){eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?")},function(module,exports){eval('module.exports = require("express");\n\n//# sourceURL=webpack:///external_%22express%22?')},function(module,exports){eval('module.exports = require("express-graphql");\n\n//# sourceURL=webpack:///external_%22express-graphql%22?')}]);